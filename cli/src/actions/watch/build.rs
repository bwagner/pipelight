// Structs
use crate::services::{self, Action};
use crate::services::{FgBg, Service};
use crate::types::{Commands, DetachableCommands, PostCommands, Trigger};
use pipelight_utils::git::{Flag, Special};
use pipelight_utils::teleport::Portal;
use std::process::exit;
// use crate::trigger;
// Globals
use std::sync::Arc;
// Watchexec
use ignore_files::{IgnoreFile, IgnoreFilter};
use std::future::Future;
use watchexec::{action::ActionHandler, Config, Watchexec};
use watchexec_events::Event;
use watchexec_filterer_ignore::IgnoreFilterer;
use watchexec_signals::Signal;
use watchexec_supervisor::job::{start_job, Job};
// Env
use std::env;
use std::path::Path;
// Globals
use crate::globals::CLI;
// Error handling
use miette::{Diagnostic, IntoDiagnostic, Result};
use thiserror::Error;

// Watchexec - Bug fix Struct
#[derive(Debug, Error, Diagnostic)]
#[error("stub")]
struct MietteStub;

/**
 * Retrieve an ignore file fullpath if any.
*/
pub fn get_ignore_path() -> Result<String> {
    // Search an ignore file to set a filter
    let mut portal = Portal::new()?;
    portal.seed(".pipelight_ignore");
    match portal.search_file() {
        Ok(_) => Ok(portal.target.file_path.unwrap()),
        Err(_) => {
            let mut portal = Portal::new()?;
            portal.seed(".gitignore");
            match portal.search_file() {
                Ok(_) => Ok(portal.target.file_path.unwrap()),
                Err(err) => return Err(err.into()),
            }
        }
    }
}

/**
Build an appropriate watcher that:
- self reconfigures on ignore file changes
- ignores pipelight autogenerated tmp files
- can trigger pipelines
*/
pub async fn build() -> Result<Arc<Watchexec>> {
    // Create a Watchexec with action handler
    let watchexec = Watchexec::new_async(action_handler)?;

    // Search for an ignore file to set a watch filter
    match get_ignore_path() {
        Ok(res) => {
            let filterer = make_filter_configuration(&res).await?;
            watchexec.config.filterer(Arc::new(filterer));
        }
        Err(_) => {
            let filterer = make_default_filter_configuration().await?;
            watchexec.config.filterer(Arc::new(filterer));
        }
    }
    // Watch only the current directory
    watchexec.config.pathset(vec![env::current_dir().unwrap()]);

    Ok(watchexec)
}

pub fn action_handler(
    mut action: ActionHandler,
) -> Box<dyn Future<Output = ActionHandler> + Send + Sync> {
    // Self reconfigure when the ignore file changes
    // reconfigure(&w_clone, &r_clone, &action).await.unwrap();

    // Pipeline execution
    watch_trigger().unwrap();

    // Handle Stop signals
    if action
        .signals()
        .any(|sig| sig == Signal::Interrupt || sig == Signal::Terminate)
    {
        action.quit();
    }

    // Actions
    return Box::new(async move { action });
}

/**
Self reconfigure when the IgnoreFile changes.
*/
pub async fn reconfigure(watchexec: &Watchexec, action: &ActionHandler) -> Result<()> {
    if let Some(ignore_path) = get_ignore_path().ok() {
        for event in action.events.iter() {
            if event
                .paths()
                .any(|(p, _)| p.to_str().unwrap() == ignore_path)
            {
                // Set Filter
                let filterer = make_filter_configuration(&ignore_path).await?;
                watchexec.config.filterer(Arc::new(filterer));
                break;
            }
        }
    }
    Ok(())
}

/**
Create an action filter based on provided ignore file path
Do not watch some files to avoid recursive watching
 */
pub async fn make_filter_configuration(path: &str) -> Result<IgnoreFilterer> {
    let path = Path::new(path);
    // Set Filter
    let applies_in = env::current_dir().into_diagnostic()?;
    let file = IgnoreFile {
        path: path.into(),
        applies_in: Some(applies_in.clone()),
        applies_to: None,
    };
    let globs = [".pipelight/", ".git/", ".cargo/", "target", ".node_modules"];
    let mut filter: IgnoreFilter = IgnoreFilter::empty(applies_in.clone());
    filter
        .add_globs(&globs, Some(&applies_in))
        .into_diagnostic()?;
    filter.add_file(&file).await.into_diagnostic()?;

    let filterer = IgnoreFilterer(filter);
    Ok(filterer)
}

/**
Create a default action filter
Do not watch some files to avoid recursive watching
 */
pub async fn make_default_filter_configuration() -> Result<IgnoreFilterer> {
    // Set Filter
    let applies_in = env::current_dir().into_diagnostic()?;

    let globs = [".pipelight/", ".git/", ".cargo/", ".node_modules/"];
    let mut filter: IgnoreFilter = IgnoreFilter::empty(applies_in.clone());
    filter
        .add_globs(&globs, Some(&applies_in))
        .into_diagnostic()?;

    let filterer = IgnoreFilterer(filter);
    Ok(filterer)
}

/**
Modify the triggering env by setting the action to watch
And try to trigger pipelines.
*/
pub fn watch_trigger() -> Result<()> {
    let flag = Some(String::from(&Flag::Special(Special::Watch)));
    let mut args = CLI.lock().unwrap().clone();
    args.commands = Commands::PostCommands(PostCommands::DetachableCommands(
        DetachableCommands::Trigger(Trigger { flag }),
    ));
    Service::new(services::Action::Trigger, Some(args))?.should_detach()?;
    Ok(())
}
